# ==============================================================================
# Veridis Decentralized Identity Protocol - PostgreSQL Backup CronJobs
# ==============================================================================
#
# This manifest defines comprehensive PostgreSQL backup CronJobs for the Veridis
# deployment, providing:
#
# ENTERPRISE BACKUP ARCHITECTURE:
#   • Multi-tier backup strategy with full, incremental, and differential backups
#   • Advanced backup orchestration with dependency management and validation
#   • Comprehensive backup verification with integrity checks and restoration testing
#   • Cross-region backup replication with disaster recovery capabilities
#   • Automated backup lifecycle management with retention policies and archival
#
# BACKUP PERFORMANCE OPTIMIZATION:
#   • Parallel backup processing with optimal resource utilization
#   • Intelligent backup scheduling with maintenance window optimization
#   • Advanced compression with multiple algorithms and performance tuning
#   • Deduplication and incremental backup strategies for efficiency
#   • Network-optimized backup transfer with bandwidth management
#
# COMPLIANCE FRAMEWORK INTEGRATION:
#   • SOC 2 Type II backup security controls with comprehensive audit logging
#   • GDPR data protection with backup encryption and data residency compliance
#   • ISO 27001 backup security management with access controls and monitoring
#   • PCI DSS secure backup storage for cardholder data environment protection
#   • FIPS 140-2 encryption compliance with validated cryptographic modules
#
# ENTERPRISE DISASTER RECOVERY:
#   • Multi-region backup distribution with geographic redundancy
#   • Point-in-time recovery with granular recovery capabilities
#   • Automated disaster recovery testing with validation procedures
#   • Business continuity with RTO/RPO guarantee and automated failover
#   • Recovery orchestration with dependency management and validation
#
# OPERATIONAL EXCELLENCE CONTROLS:
#   • Automated backup monitoring with comprehensive metrics and alerting
#   • Backup validation with integrity verification and restoration testing
#   • Incident response with automated recovery and escalation procedures
#   • Capacity management with backup storage optimization and forecasting
#   • Cost optimization with intelligent backup lifecycle and storage tiering
#
# ==============================================================================

# ==============================================================================
# PostgreSQL Full Backup CronJob - Weekly Complete Database Backup
# ==============================================================================
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-full-backup
  namespace: veridis-database

  # Core resource identification labels
  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: veridis-production
    app.kubernetes.io/version: "15.4"
    app.kubernetes.io/component: backup-cronjob
    app.kubernetes.io/part-of: veridis-protocol
    app.kubernetes.io/managed-by: kustomize

    # Backup specific classification
    backup.veridis.xyz/type: full-backup
    backup.veridis.xyz/tier: enterprise
    backup.veridis.xyz/strategy: complete-database
    backup.veridis.xyz/frequency: weekly
    backup.veridis.xyz/retention: long-term

    # Performance classification
    performance.veridis.xyz/tier: high
    performance.veridis.xyz/resource-class: backup-optimized
    performance.veridis.xyz/parallelism: enabled
    performance.veridis.xyz/compression: high-ratio
    performance.veridis.xyz/network-optimization: enabled

    # Business classification
    business.veridis.xyz/criticality: mission-critical
    business.veridis.xyz/cost-tier: premium
    business.veridis.xyz/revenue-impact: direct
    business.veridis.xyz/disaster-recovery: "true"
    business.veridis.xyz/compliance-backup: "true"

    # Availability and reliability
    availability.veridis.xyz/ha-tier: maximum
    availability.veridis.xyz/backup-redundancy: multi-region
    availability.veridis.xyz/disaster-recovery: cross-region
    availability.veridis.xyz/validation: automated
    availability.veridis.xyz/sla-target: "99.99"

    # Security classification
    security.veridis.xyz/encryption-at-rest: "aes-256"
    security.veridis.xyz/encryption-in-transit: "tls-1.3"
    security.veridis.xyz/access-control: "rbac-strict"
    security.veridis.xyz/audit-logging: "comprehensive"
    security.veridis.xyz/data-classification: "confidential"

    # Backup management labels
    backup.veridis.xyz/schedule: "weekly-maintenance"
    backup.veridis.xyz/compression-algorithm: "lz4"
    backup.veridis.xyz/encryption-key: "backup-master-key"
    backup.veridis.xyz/storage-class: "backup-standard"
    backup.veridis.xyz/cross-region-replication: "enabled"

    # Operational labels
    veridis.xyz/environment: production
    veridis.xyz/team: database-administration
    veridis.xyz/cost-center: infrastructure
    veridis.xyz/business-unit: identity-protocol

    # Compliance framework labels
    compliance.veridis.xyz/soc2: "backup-control-full"
    compliance.veridis.xyz/gdpr: "data-backup-protection"
    compliance.veridis.xyz/iso27001: "backup-security-management"
    compliance.veridis.xyz/pci-dss: "secure-backup-storage"
    compliance.veridis.xyz/regulatory-retention: "7-years"
    governance.veridis.xyz/policy-enforcement: "strict"

    # Monitoring and observability
    monitoring.veridis.xyz/metrics-collection: "backup-performance"
    monitoring.veridis.xyz/alerting-integration: "pagerduty"
    monitoring.veridis.xyz/health-monitoring: "comprehensive"
    monitoring.veridis.xyz/sla-monitoring: "enabled"

  annotations:
    # Backup purpose and specifications
    veridis.xyz/description: "Weekly full database backup with enterprise-grade security, compression, and cross-region replication"
    veridis.xyz/purpose: "Provides complete database backup for disaster recovery, compliance, and business continuity"
    veridis.xyz/scope: "Complete database dump, schema, data, indexes, stored procedures, triggers, and metadata"

    # Backup architecture and strategy
    backup.veridis.xyz/architecture: "Full database backup with parallel processing, compression, encryption, and validation"
    backup.veridis.xyz/backup-method: "pg_dump with custom format, parallel processing, and compression optimization"
    backup.veridis.xyz/validation-strategy: "Automated backup integrity verification with restoration testing"
    backup.veridis.xyz/recovery-capabilities: "Complete database restoration with point-in-time recovery support"

    # Performance optimization and scheduling
    performance.veridis.xyz/maintenance-window: "Sunday 02:00-06:00 UTC during low-traffic period"
    performance.veridis.xyz/resource-allocation: "Dedicated backup resources with CPU and memory optimization"
    performance.veridis.xyz/parallel-jobs: "4 parallel backup jobs for optimal performance"
    performance.veridis.xyz/compression-ratio: "Average 70% compression with LZ4 algorithm"
    performance.veridis.xyz/estimated-duration: "2-3 hours for complete 1TB database"

    # Security and encryption specifications
    security.veridis.xyz/encryption-algorithm: "AES-256-GCM with unique encryption keys per backup"
    security.veridis.xyz/key-management: "HashiCorp Vault integration with automatic key rotation"
    security.veridis.xyz/access-restrictions: "Backup operator role with least privilege access"
    security.veridis.xyz/audit-requirements: "All backup operations logged with comprehensive audit trail"
    security.veridis.xyz/secure-transport: "TLS 1.3 encrypted transfer to backup storage"

    # Compliance and regulatory requirements
    compliance.veridis.xyz/retention-policy: "7 years minimum retention with automated lifecycle management"
    compliance.veridis.xyz/data-residency: "Backup data stored in compliant US and EU regions"
    compliance.veridis.xyz/immutable-storage: "WORM compliance with tamper-proof backup storage"
    compliance.veridis.xyz/legal-hold: "Legal hold capability for litigation and regulatory requirements"
    compliance.veridis.xyz/audit-trail: "Immutable audit trail with blockchain-anchored integrity"

    # Disaster recovery and business continuity
    disaster-recovery.veridis.xyz/cross-region-replication: "Automated replication to 3 geographic regions"
    disaster-recovery.veridis.xyz/recovery-testing: "Monthly automated disaster recovery testing"
    disaster-recovery.veridis.xyz/rto-target: "4 hours maximum recovery time objective"
    disaster-recovery.veridis.xyz/rpo-target: "1 week maximum recovery point objective"
    disaster-recovery.veridis.xyz/failover-automation: "Automated failover with validation procedures"

    # Monitoring and alerting specifications
    monitoring.veridis.xyz/success-notification: "Backup completion notification to operations team"
    monitoring.veridis.xyz/failure-escalation: "Immediate PagerDuty alert for backup failures"
    monitoring.veridis.xyz/performance-monitoring: "Backup duration, size, compression ratio tracking"
    monitoring.veridis.xyz/capacity-monitoring: "Backup storage utilization and growth forecasting"
    monitoring.veridis.xyz/sla-reporting: "Monthly backup SLA compliance reporting"

    # Cost optimization and lifecycle management
    cost.veridis.xyz/storage-optimization: "Intelligent storage tiering with cost-performance balance"
    cost.veridis.xyz/lifecycle-transitions: "Standard (30d) -> IA (90d) -> Glacier (1y) -> Deep Archive (7y)"
    cost.veridis.xyz/compression-savings: "70% average storage savings with LZ4 compression"
    cost.veridis.xyz/deduplication: "Cross-backup deduplication for additional storage savings"

    # Operational procedures and contacts
    veridis.xyz/owner: "database-team@veridis.xyz"
    veridis.xyz/backup-admin: "backup-admin@veridis.xyz"
    veridis.xyz/escalation: "database-manager@veridis.xyz"
    veridis.xyz/emergency-contact: "backup-oncall@veridis.xyz"

    # Documentation and procedures
    veridis.xyz/documentation: "https://docs.veridis.xyz/backup/postgres-full-backup"
    veridis.xyz/runbook: "https://runbooks.veridis.xyz/backup/postgres-full-backup-cronjob"
    veridis.xyz/disaster-recovery-plan: "https://docs.veridis.xyz/disaster-recovery/postgres-backup"
    veridis.xyz/troubleshooting: "https://docs.veridis.xyz/troubleshooting/postgres-backup"

# CronJob specification
spec:
  # Schedule: Every Sunday at 2:00 AM UTC (low traffic period)
  schedule: "0 2 * * 0"

  # Timezone for schedule interpretation
  timeZone: "UTC"

  # Concurrency policy to prevent overlapping backups
  concurrencyPolicy: Forbid

  # Keep last 3 successful jobs and 1 failed job for troubleshooting
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1

  # Starting deadline for delayed jobs (1 hour)
  startingDeadlineSeconds: 3600

  # Suspend flag for maintenance (can be toggled)
  suspend: false

  jobTemplate:
    metadata:
      labels:
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/instance: veridis-production
        app.kubernetes.io/component: backup-job
        backup.veridis.xyz/type: full-backup
        backup.veridis.xyz/schedule: weekly

      annotations:
        veridis.xyz/job-type: "database-full-backup"
        backup.veridis.xyz/backup-window: "maintenance-window"

    spec:
      # Job completion and retry settings
      completions: 1
      parallelism: 1
      backoffLimit: 2
      activeDeadlineSeconds: 14400  # 4 hours maximum execution time

      template:
        metadata:
          labels:
            app.kubernetes.io/name: postgresql
            app.kubernetes.io/instance: veridis-production
            app.kubernetes.io/component: backup-pod
            backup.veridis.xyz/type: full-backup

          annotations:
            veridis.xyz/pod-type: "backup-executor"
            backup.veridis.xyz/backup-method: "pg_dump-parallel"

        spec:
          # Service account with backup permissions
          serviceAccountName: postgres-backup-sa

          # Security context for backup operations
          securityContext:
            runAsNonRoot: true
            runAsUser: 999
            runAsGroup: 999
            fsGroup: 999
            seccompProfile:
              type: RuntimeDefault

          # Restart policy for failed backups
          restartPolicy: OnFailure

          # Node selection for backup workloads
          nodeSelector:
            veridis.xyz/node-type: backup-optimized
            kubernetes.io/arch: amd64

          # Tolerations for backup nodes
          tolerations:
          - key: "veridis.xyz/backup-workload"
            operator: "Equal"
            value: "true"
            effect: "NoSchedule"

          # Affinity rules for optimal backup performance
          affinity:
            nodeAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
              - weight: 100
                preference:
                  matchExpressions:
                  - key: "veridis.xyz/storage-optimized"
                    operator: In
                    values: ["true"]

            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
              - weight: 100
                podAffinityTerm:
                  labelSelector:
                    matchExpressions:
                    - key: "app.kubernetes.io/component"
                      operator: In
                      values: ["database"]
                  topologyKey: "kubernetes.io/hostname"

          # Init container for backup preparation
          initContainers:
          - name: backup-preparation
            image: veridis/postgres-backup-tools:15.4-enterprise
            imagePullPolicy: IfNotPresent

            securityContext:
              runAsNonRoot: true
              runAsUser: 999
              runAsGroup: 999
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL

            env:
            - name: BACKUP_TYPE
              value: "full"
            - name: BACKUP_TIMESTAMP
              value: "$(date +%Y%m%d_%H%M%S)"
            - name: POSTGRES_HOST
              value: "veridis-postgres-primary.veridis-database.svc.cluster.local"
            - name: POSTGRES_PORT
              value: "5432"
            - name: POSTGRES_DATABASE
              value: "veridis"

            envFrom:
            - secretRef:
                name: postgres-backup-secret

            volumeMounts:
            - name: backup-staging
              mountPath: /backup/staging
            - name: backup-scripts
              mountPath: /scripts
              readOnly: true
            - name: tmp
              mountPath: /tmp

            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail

              echo "Starting backup preparation..."

              # Create backup directory structure
              mkdir -p /backup/staging/full-backup-$(date +%Y%m%d_%H%M%S)

              # Verify database connectivity
              pg_isready -h $POSTGRES_HOST -p $POSTGRES_PORT -d $POSTGRES_DATABASE -U postgres

              # Pre-backup database health check
              /scripts/pre-backup-health-check.sh

              echo "Backup preparation completed successfully"

            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 500m
                memory: 512Mi

          # Main backup container
          containers:
          - name: postgres-full-backup
            image: veridis/postgres-backup-tools:15.4-enterprise
            imagePullPolicy: IfNotPresent

            securityContext:
              runAsNonRoot: true
              runAsUser: 999
              runAsGroup: 999
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL

            env:
            - name: BACKUP_TYPE
              value: "full"
            - name: BACKUP_TIMESTAMP
              valueFrom:
                fieldRef:
                  fieldPath: metadata.creationTimestamp
            - name: POSTGRES_HOST
              value: "veridis-postgres-primary.veridis-database.svc.cluster.local"
            - name: POSTGRES_PORT
              value: "5432"
            - name: POSTGRES_DATABASE
              value: "veridis"
            - name: POSTGRES_USER
              value: "backup"
            - name: BACKUP_COMPRESSION
              value: "lz4"
            - name: BACKUP_ENCRYPTION
              value: "enabled"
            - name: BACKUP_PARALLEL_JOBS
              value: "4"
            - name: BACKUP_VALIDATION
              value: "enabled"
            - name: CROSS_REGION_REPLICATION
              value: "enabled"
            - name: AWS_DEFAULT_REGION
              value: "us-west-2"
            - name: BACKUP_RETENTION_DAYS
              value: "2555"  # 7 years

            envFrom:
            - secretRef:
                name: postgres-backup-secret
            - configMapRef:
                name: postgres-backup-config

            volumeMounts:
            - name: backup-staging
              mountPath: /backup/staging
            - name: backup-storage
              mountPath: /backup/storage
            - name: backup-scripts
              mountPath: /scripts
              readOnly: true
            - name: backup-config
              mountPath: /config
              readOnly: true
            - name: tmp
              mountPath: /tmp

            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail

              # Source backup functions
              source /scripts/backup-functions.sh

              # Initialize backup environment
              initialize_backup_environment

              # Set backup variables
              BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
              BACKUP_FILENAME="veridis-postgres-full-${BACKUP_DATE}.backup"
              BACKUP_PATH="/backup/staging/${BACKUP_FILENAME}"

              echo "Starting PostgreSQL full backup: ${BACKUP_FILENAME}"

              # Pre-backup validation
              validate_database_connection
              validate_backup_permissions
              validate_storage_capacity

              # Execute full backup with parallel processing
              echo "Executing pg_dump with parallel processing..."
              pg_dump \
                --host=${POSTGRES_HOST} \
                --port=${POSTGRES_PORT} \
                --username=${POSTGRES_USER} \
                --dbname=${POSTGRES_DATABASE} \
                --format=custom \
                --compress=0 \
                --jobs=${BACKUP_PARALLEL_JOBS} \
                --verbose \
                --file=${BACKUP_PATH} \
                --exclude-table-data='audit_log_*' \
                --exclude-table-data='session_temp_*'

              # Verify backup integrity
              echo "Verifying backup integrity..."
              pg_restore --list ${BACKUP_PATH} > /dev/null

              # Apply compression
              echo "Applying LZ4 compression..."
              lz4 -9 ${BACKUP_PATH} ${BACKUP_PATH}.lz4
              rm ${BACKUP_PATH}
              BACKUP_PATH="${BACKUP_PATH}.lz4"

              # Apply encryption
              echo "Encrypting backup..."
              encrypt_backup_file ${BACKUP_PATH}
              BACKUP_PATH="${BACKUP_PATH}.enc"

              # Calculate checksums
              echo "Calculating checksums..."
              calculate_backup_checksums ${BACKUP_PATH}

              # Upload to primary backup storage
              echo "Uploading to primary backup storage..."
              upload_to_primary_storage ${BACKUP_PATH}

              # Cross-region replication
              echo "Initiating cross-region replication..."
              replicate_to_disaster_recovery_regions ${BACKUP_PATH}

              # Backup validation
              echo "Performing post-backup validation..."
              validate_backup_integrity ${BACKUP_PATH}

              # Update backup catalog
              echo "Updating backup catalog..."
              update_backup_catalog ${BACKUP_FILENAME} "full" "success"

              # Cleanup staging area
              echo "Cleaning up staging area..."
              cleanup_staging_area

              # Send success notification
              send_backup_notification "success" ${BACKUP_FILENAME}

              echo "PostgreSQL full backup completed successfully: ${BACKUP_FILENAME}"

            resources:
              requests:
                cpu: 2000m
                memory: 4Gi
              limits:
                cpu: 4000m
                memory: 8Gi

            # Liveness probe to detect hung backups
            livenessProbe:
              exec:
                command:
                - /bin/bash
                - -c
                - |
                  # Check if backup process is making progress
                  if [ -f /tmp/backup-progress ]; then
                    LAST_UPDATE=$(stat -c %Y /tmp/backup-progress)
                    CURRENT_TIME=$(date +%s)
                    TIME_DIFF=$((CURRENT_TIME - LAST_UPDATE))
                    # Fail if no progress for 30 minutes
                    [ $TIME_DIFF -lt 1800 ]
                  else
                    # Allow initial startup time
                    true
                  fi
              initialDelaySeconds: 300
              periodSeconds: 300
              timeoutSeconds: 30
              failureThreshold: 3

          # Volumes for backup operations
          volumes:
          - name: backup-staging
            persistentVolumeClaim:
              claimName: postgres-backup-staging

          - name: backup-storage
            persistentVolumeClaim:
              claimName: postgres-backup-storage

          - name: backup-scripts
            configMap:
              name: postgres-backup-scripts
              defaultMode: 0755

          - name: backup-config
            configMap:
              name: postgres-backup-config
              defaultMode: 0644

          - name: tmp
            emptyDir:
              sizeLimit: 1Gi

---
# ==============================================================================
# PostgreSQL Incremental Backup CronJob - Daily Incremental Backup
# ==============================================================================
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-incremental-backup
  namespace: veridis-database

  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: veridis-production
    app.kubernetes.io/version: "15.4"
    app.kubernetes.io/component: backup-cronjob
    app.kubernetes.io/part-of: veridis-protocol
    app.kubernetes.io/managed-by: kustomize

    backup.veridis.xyz/type: incremental-backup
    backup.veridis.xyz/tier: enterprise
    backup.veridis.xyz/strategy: incremental-changes
    backup.veridis.xyz/frequency: daily
    backup.veridis.xyz/retention: medium-term

    performance.veridis.xyz/tier: standard
    performance.veridis.xyz/resource-class: backup-standard
    performance.veridis.xyz/parallelism: limited
    performance.veridis.xyz/compression: standard
    performance.veridis.xyz/network-optimization: enabled

    business.veridis.xyz/criticality: business-critical
    business.veridis.xyz/cost-tier: standard
    business.veridis.xyz/revenue-impact: indirect
    business.veridis.xyz/disaster-recovery: "true"
    business.veridis.xyz/point-in-time-recovery: "true"

    availability.veridis.xyz/ha-tier: high
    availability.veridis.xyz/backup-redundancy: regional
    availability.veridis.xyz/disaster-recovery: regional
    availability.veridis.xyz/validation: automated
    availability.veridis.xyz/sla-target: "99.9"

    security.veridis.xyz/encryption-at-rest: "aes-256"
    security.veridis.xyz/encryption-in-transit: "tls-1.3"
    security.veridis.xyz/access-control: "rbac-standard"
    security.veridis.xyz/audit-logging: "standard"
    security.veridis.xyz/data-classification: "internal"

    backup.veridis.xyz/schedule: "daily-incremental"
    backup.veridis.xyz/compression-algorithm: "gzip"
    backup.veridis.xyz/encryption-key: "backup-incremental-key"
    backup.veridis.xyz/storage-class: "backup-standard"
    backup.veridis.xyz/dependency: "full-backup"

    veridis.xyz/environment: production
    veridis.xyz/team: database-administration
    veridis.xyz/cost-center: infrastructure
    veridis.xyz/business-unit: identity-protocol

    compliance.veridis.xyz/soc2: "backup-control-incremental"
    compliance.veridis.xyz/gdpr: "incremental-backup-protection"
    compliance.veridis.xyz/iso27001: "incremental-backup-security"
    governance.veridis.xyz/policy-enforcement: "standard"

  annotations:
    veridis.xyz/description: "Daily incremental backup for PostgreSQL with change-based backup strategy and point-in-time recovery"
    veridis.xyz/purpose: "Provides daily incremental backup for minimal recovery point objective and efficient storage utilization"
    veridis.xyz/scope: "Changed data since last backup, transaction logs, and incremental schema changes"

    # Incremental backup strategy
    backup.veridis.xyz/architecture: "WAL-based incremental backup with change tracking and efficient storage"
    backup.veridis.xyz/backup-method: "pg_basebackup with WAL streaming and incremental processing"
    backup.veridis.xyz/dependency-management: "Requires successful full backup as baseline"
    backup.veridis.xyz/recovery-chain: "Part of recovery chain with full backup dependency"

    # Performance and scheduling
    performance.veridis.xyz/maintenance-window: "Daily 03:00-04:00 UTC during low-traffic period"
    performance.veridis.xyz/estimated-duration: "30-60 minutes depending on change volume"
    performance.veridis.xyz/resource-optimization: "Optimized for minimal impact on production workloads"
    performance.veridis.xyz/network-efficiency: "Incremental transfer with bandwidth optimization"

    # Recovery capabilities
    recovery.veridis.xyz/point-in-time-recovery: "Daily granularity with WAL replay capability"
    recovery.veridis.xyz/recovery-dependency: "Requires full backup plus all incremental backups in chain"
    recovery.veridis.xyz/recovery-time: "1-2 hours including full backup restoration and incremental replay"
    recovery.veridis.xyz/automated-testing: "Weekly incremental backup restoration testing"

    # Retention and lifecycle
    lifecycle.veridis.xyz/retention-policy: "30 days incremental backup retention"
    lifecycle.veridis.xyz/cleanup-automation: "Automated cleanup after retention period"
    lifecycle.veridis.xyz/chain-management: "Automatic backup chain validation and management"

    veridis.xyz/owner: "database-team@veridis.xyz"
    veridis.xyz/backup-admin: "backup-admin@veridis.xyz"

spec:
  # Schedule: Every day at 3:00 AM UTC (low traffic period)
  schedule: "0 3 * * *"

  timeZone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 7   # Keep one week of successful jobs
  failedJobsHistoryLimit: 3
  startingDeadlineSeconds: 1800   # 30 minutes deadline
  suspend: false

  jobTemplate:
    metadata:
      labels:
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/instance: veridis-production
        app.kubernetes.io/component: backup-job
        backup.veridis.xyz/type: incremental-backup
        backup.veridis.xyz/schedule: daily

      annotations:
        veridis.xyz/job-type: "database-incremental-backup"
        backup.veridis.xyz/backup-window: "daily-window"

    spec:
      completions: 1
      parallelism: 1
      backoffLimit: 2
      activeDeadlineSeconds: 7200  # 2 hours maximum execution time

      template:
        metadata:
          labels:
            app.kubernetes.io/name: postgresql
            app.kubernetes.io/instance: veridis-production
            app.kubernetes.io/component: backup-pod
            backup.veridis.xyz/type: incremental-backup

          annotations:
            veridis.xyz/pod-type: "incremental-backup-executor"
            backup.veridis.xyz/backup-method: "wal-streaming"

        spec:
          serviceAccountName: postgres-backup-sa

          securityContext:
            runAsNonRoot: true
            runAsUser: 999
            runAsGroup: 999
            fsGroup: 999
            seccompProfile:
              type: RuntimeDefault

          restartPolicy: OnFailure

          nodeSelector:
            veridis.xyz/node-type: backup-standard
            kubernetes.io/arch: amd64

          tolerations:
          - key: "veridis.xyz/backup-workload"
            operator: "Equal"
            value: "true"
            effect: "NoSchedule"

          containers:
          - name: postgres-incremental-backup
            image: veridis/postgres-backup-tools:15.4-enterprise
            imagePullPolicy: IfNotPresent

            securityContext:
              runAsNonRoot: true
              runAsUser: 999
              runAsGroup: 999
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL

            env:
            - name: BACKUP_TYPE
              value: "incremental"
            - name: BACKUP_TIMESTAMP
              valueFrom:
                fieldRef:
                  fieldPath: metadata.creationTimestamp
            - name: POSTGRES_HOST
              value: "veridis-postgres-primary.veridis-database.svc.cluster.local"
            - name: POSTGRES_PORT
              value: "5432"
            - name: POSTGRES_DATABASE
              value: "veridis"
            - name: POSTGRES_USER
              value: "backup"
            - name: BACKUP_COMPRESSION
              value: "gzip"
            - name: BACKUP_ENCRYPTION
              value: "enabled"
            - name: WAL_STREAMING
              value: "enabled"
            - name: BACKUP_VALIDATION
              value: "enabled"
            - name: AWS_DEFAULT_REGION
              value: "us-west-2"
            - name: BACKUP_RETENTION_DAYS
              value: "30"

            envFrom:
            - secretRef:
                name: postgres-backup-secret
            - configMapRef:
                name: postgres-backup-config

            volumeMounts:
            - name: backup-staging
              mountPath: /backup/staging
            - name: backup-storage
              mountPath: /backup/storage
            - name: backup-scripts
              mountPath: /scripts
              readOnly: true
            - name: tmp
              mountPath: /tmp

            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail

              source /scripts/backup-functions.sh

              # Initialize incremental backup environment
              initialize_incremental_backup_environment

              BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
              BACKUP_FILENAME="veridis-postgres-incremental-${BACKUP_DATE}.backup"
              BACKUP_PATH="/backup/staging/${BACKUP_FILENAME}"

              echo "Starting PostgreSQL incremental backup: ${BACKUP_FILENAME}"

              # Validate backup chain
              validate_backup_chain

              # Find last backup LSN
              LAST_BACKUP_LSN=$(get_last_backup_lsn)
              echo "Last backup LSN: ${LAST_BACKUP_LSN}"

              # Execute incremental backup
              echo "Executing incremental backup from LSN: ${LAST_BACKUP_LSN}"
              pg_basebackup \
                --host=${POSTGRES_HOST} \
                --port=${POSTGRES_PORT} \
                --username=${POSTGRES_USER} \
                --pgdata=${BACKUP_PATH} \
                --format=tar \
                --gzip \
                --compress=6 \
                --wal-method=stream \
                --progress \
                --verbose \
                --checkpoint=spread

              # Record current LSN
              CURRENT_LSN=$(get_current_lsn)
              echo "Current LSN: ${CURRENT_LSN}"

              # Create backup metadata
              create_backup_metadata ${BACKUP_FILENAME} ${LAST_BACKUP_LSN} ${CURRENT_LSN}

              # Apply encryption
              echo "Encrypting incremental backup..."
              encrypt_backup_file ${BACKUP_PATH}

              # Calculate checksums
              calculate_backup_checksums ${BACKUP_PATH}

              # Upload to backup storage
              upload_to_backup_storage ${BACKUP_PATH}

              # Validate backup integrity
              validate_incremental_backup_integrity ${BACKUP_PATH}

              # Update backup catalog
              update_backup_catalog ${BACKUP_FILENAME} "incremental" "success"

              # Cleanup old incremental backups
              cleanup_old_incremental_backups

              # Send success notification
              send_backup_notification "success" ${BACKUP_FILENAME}

              echo "PostgreSQL incremental backup completed successfully: ${BACKUP_FILENAME}"

            resources:
              requests:
                cpu: 500m
                memory: 1Gi
              limits:
                cpu: 1000m
                memory: 2Gi

            livenessProbe:
              exec:
                command:
                - /bin/bash
                - -c
                - |
                  if [ -f /tmp/incremental-backup-progress ]; then
                    LAST_UPDATE=$(stat -c %Y /tmp/incremental-backup-progress)
                    CURRENT_TIME=$(date +%s)
                    TIME_DIFF=$((CURRENT_TIME - LAST_UPDATE))
                    [ $TIME_DIFF -lt 900 ]  # 15 minutes
                  else
                    true
                  fi
              initialDelaySeconds: 180
              periodSeconds: 180
              timeoutSeconds: 30
              failureThreshold: 3

          volumes:
          - name: backup-staging
            persistentVolumeClaim:
              claimName: postgres-backup-staging

          - name: backup-storage
            persistentVolumeClaim:
              claimName: postgres-backup-storage

          - name: backup-scripts
            configMap:
              name: postgres-backup-scripts
              defaultMode: 0755

          - name: tmp
            emptyDir:
              sizeLimit: 500Mi

---
# ==============================================================================
# PostgreSQL WAL Archive Backup CronJob - Continuous WAL Archiving
# ==============================================================================
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-wal-archive-backup
  namespace: veridis-database

  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: veridis-production
    app.kubernetes.io/version: "15.4"
    app.kubernetes.io/component: backup-cronjob
    app.kubernetes.io/part-of: veridis-protocol
    app.kubernetes.io/managed-by: kustomize

    backup.veridis.xyz/type: wal-archive-backup
    backup.veridis.xyz/tier: enterprise
    backup.veridis.xyz/strategy: continuous-archiving
    backup.veridis.xyz/frequency: hourly
    backup.veridis.xyz/retention: short-term

    performance.veridis.xyz/tier: standard
    performance.veridis.xyz/resource-class: backup-lightweight
    performance.veridis.xyz/compression: high-ratio
    performance.veridis.xyz/network-optimization: enabled

    business.veridis.xyz/criticality: business-critical
    business.veridis.xyz/cost-tier: standard
    business.veridis.xyz/revenue-impact: indirect
    business.veridis.xyz/point-in-time-recovery: "true"

    availability.veridis.xyz/ha-tier: high
    availability.veridis.xyz/backup-redundancy: multi-zone
    availability.veridis.xyz/validation: continuous
    availability.veridis.xyz/sla-target: "99.9"

    security.veridis.xyz/encryption-at-rest: "aes-256"
    security.veridis.xyz/encryption-in-transit: "tls-1.3"
    security.veridis.xyz/access-control: "rbac-standard"
    security.veridis.xyz/data-classification: "internal"

    backup.veridis.xyz/schedule: "hourly-wal"
    backup.veridis.xyz/compression-algorithm: "lz4"
    backup.veridis.xyz/storage-class: "backup-fast"
    backup.veridis.xyz/archival-policy: "continuous"

    veridis.xyz/environment: production
    veridis.xyz/team: database-administration
    veridis.xyz/cost-center: infrastructure
    veridis.xyz/business-unit: identity-protocol

    compliance.veridis.xyz/soc2: "wal-archive-control"
    compliance.veridis.xyz/gdpr: "transaction-log-protection"
    governance.veridis.xyz/policy-enforcement: "standard"

  annotations:
    veridis.xyz/description: "Hourly WAL archive backup for PostgreSQL with continuous transaction log archiving and point-in-time recovery"
    veridis.xyz/purpose: "Provides continuous WAL archiving for minimal recovery point objective and transaction-level recovery"
    veridis.xyz/scope: "Write-ahead log segments, transaction logs, and point-in-time recovery data"

    # WAL archiving strategy
    backup.veridis.xyz/architecture: "Continuous WAL archiving with compression, encryption, and multi-zone storage"
    backup.veridis.xyz/archival-method: "PostgreSQL WAL archiving with custom archive command"
    backup.veridis.xyz/recovery-granularity: "Transaction-level point-in-time recovery capability"
    backup.veridis.xyz/retention-strategy: "7-day WAL retention with automated cleanup"

    # Performance optimization
    performance.veridis.xyz/wal-compression: "LZ4 compression for optimal performance and storage efficiency"
    performance.veridis.xyz/parallel-archiving: "Parallel WAL segment processing for high-throughput workloads"
    performance.veridis.xyz/network-optimization: "Optimized network transfer with compression and batching"

    # Point-in-time recovery capabilities
    recovery.veridis.xyz/granularity: "Transaction-level point-in-time recovery with sub-second precision"
    recovery.veridis.xyz/recovery-window: "7 days continuous point-in-time recovery window"
    recovery.veridis.xyz/recovery-validation: "Automated WAL replay testing for recovery validation"

    veridis.xyz/owner: "database-team@veridis.xyz"
    veridis.xyz/wal-admin: "wal-admin@veridis.xyz"

spec:
  # Schedule: Every hour at minute 30
  schedule: "30 * * * *"

  timeZone: "UTC"
  concurrencyPolicy: Replace    # Allow overlapping for continuous archiving
  successfulJobsHistoryLimit: 24  # Keep 24 hours of successful jobs
  failedJobsHistoryLimit: 5
  startingDeadlineSeconds: 900  # 15 minutes deadline
  suspend: false

  jobTemplate:
    metadata:
      labels:
        app.kubernetes.io/name: postgresql
        app.kubernetes.io/instance: veridis-production
        app.kubernetes.io/component: backup-job
        backup.veridis.xyz/type: wal-archive-backup
        backup.veridis.xyz/schedule: hourly

      annotations:
        veridis.xyz/job-type: "database-wal-archive-backup"
        backup.veridis.xyz/backup-window: "continuous"

    spec:
      completions: 1
      parallelism: 1
      backoffLimit: 1
      activeDeadlineSeconds: 1800  # 30 minutes maximum execution time

      template:
        metadata:
          labels:
            app.kubernetes.io/name: postgresql
            app.kubernetes.io/instance: veridis-production
            app.kubernetes.io/component: backup-pod
            backup.veridis.xyz/type: wal-archive-backup

          annotations:
            veridis.xyz/pod-type: "wal-archive-executor"
            backup.veridis.xyz/backup-method: "wal-archiving"

        spec:
          serviceAccountName: postgres-backup-sa

          securityContext:
            runAsNonRoot: true
            runAsUser: 999
            runAsGroup: 999
            fsGroup: 999
            seccompProfile:
              type: RuntimeDefault

          restartPolicy: OnFailure

          nodeSelector:
            veridis.xyz/node-type: backup-standard
            kubernetes.io/arch: amd64

          containers:
          - name: postgres-wal-archive-backup
            image: veridis/postgres-backup-tools:15.4-enterprise
            imagePullPolicy: IfNotPresent

            securityContext:
              runAsNonRoot: true
              runAsUser: 999
              runAsGroup: 999
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop:
                - ALL

            env:
            - name: BACKUP_TYPE
              value: "wal-archive"
            - name: POSTGRES_HOST
              value: "veridis-postgres-primary.veridis-database.svc.cluster.local"
            - name: POSTGRES_PORT
              value: "5432"
            - name: POSTGRES_USER
              value: "backup"
            - name: WAL_COMPRESSION
              value: "lz4"
            - name: WAL_ENCRYPTION
              value: "enabled"
            - name: AWS_DEFAULT_REGION
              value: "us-west-2"
            - name: WAL_RETENTION_DAYS
              value: "7"

            envFrom:
            - secretRef:
                name: postgres-backup-secret
            - configMapRef:
                name: postgres-backup-config

            volumeMounts:
            - name: wal-archive-storage
              mountPath: /wal/archive
            - name: backup-scripts
              mountPath: /scripts
              readOnly: true
            - name: tmp
              mountPath: /tmp

            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail

              source /scripts/backup-functions.sh

              echo "Starting PostgreSQL WAL archive backup..."

              # Initialize WAL archiving environment
              initialize_wal_archive_environment

              # Process pending WAL segments
              process_pending_wal_segments

              # Compress and encrypt WAL segments
              compress_and_encrypt_wal_segments

              # Upload WAL segments to archive storage
              upload_wal_segments_to_archive

              # Validate WAL archive integrity
              validate_wal_archive_integrity

              # Cleanup old WAL segments
              cleanup_old_wal_segments

              # Update WAL archive catalog
              update_wal_archive_catalog

              echo "PostgreSQL WAL archive backup completed successfully"

            resources:
              requests:
                cpu: 200m
                memory: 256Mi
              limits:
                cpu: 500m
                memory: 512Mi

          volumes:
          - name: wal-archive-storage
            persistentVolumeClaim:
              claimName: postgres-wal-archive

          - name: backup-scripts
            configMap:
              name: postgres-backup-scripts
              defaultMode: 0755

          - name: tmp
            emptyDir:
              sizeLimit: 100Mi

---
# ==============================================================================
# PostgreSQL Backup Validation CronJob - Backup Integrity Verification
# ==============================================================================
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup-validation
  namespace: veridis-database

  labels:
    app.kubernetes.io/name: postgresql
    app.kubernetes.io/instance: veridis-production
    app.kubernetes.io/version: "15.4"
    app.kubernetes.io/component: backup-validation
    app.kubernetes.io/part-of: veridis-protocol
    app.kubernetes.io/managed-by: kustomize

    backup.veridis.xyz/type: backup-validation
    backup.veridis.xyz/tier: enterprise
    backup.veridis.xyz/strategy: integrity-verification
    backup.veridis.xyz/frequency: weekly
    backup.veridis.xyz/validation-type: comprehensive

    business.veridis.xyz/criticality: mission-critical
    business.veridis.xyz/cost-tier: premium
    business.veridis.xyz/disaster-recovery: "true"
    business.veridis.xyz/compliance-validation: "true"

    availability.veridis.xyz/ha-tier: maximum
    availability.veridis.xyz/validation: comprehensive
    availability.veridis.xyz/disaster-recovery-testing: "true"

    security.veridis.xyz/validation-security: "comprehensive"
    security.veridis.xyz/audit-logging: "comprehensive"

    veridis.xyz/environment: production
    veridis.xyz/team: database-administration
    veridis.xyz/cost-center: infrastructure
    veridis.xyz/business-unit: identity-protocol

    compliance.veridis.xyz/soc2: "backup-validation-control"
    compliance.veridis.xyz/disaster-recovery-testing: "automated"
    governance.veridis.xyz/policy-enforcement: "strict"

  annotations:
    veridis.xyz/description: "Weekly backup validation and disaster recovery testing with comprehensive integrity verification"
    veridis.xyz/purpose: "Validates backup integrity, tests disaster recovery procedures, and ensures backup reliability"
    veridis.xyz/scope: "Backup integrity verification, restoration testing, disaster recovery validation"

spec:
  # Schedule: Every Sunday at 4:00 AM UTC (after full backup completion)
  schedule: "0 4 * * 0"

  timeZone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 4   # Keep one month of validation results
  failedJobsHistoryLimit: 2
  startingDeadlineSeconds: 3600
  suspend: false

  jobTemplate:
    spec:
      completions: 1
      parallelism: 1
      backoffLimit: 1
      activeDeadlineSeconds: 10800  # 3 hours for comprehensive validation

      template:
        spec:
          serviceAccountName: postgres-backup-validation-sa

          securityContext:
            runAsNonRoot: true
            runAsUser: 999
            runAsGroup: 999
            fsGroup: 999
            seccompProfile:
              type: RuntimeDefault

          restartPolicy: OnFailure

          containers:
          - name: postgres-backup-validation
            image: veridis/postgres-backup-tools:15.4-enterprise
            imagePullPolicy: IfNotPresent

            env:
            - name: VALIDATION_TYPE
              value: "comprehensive"
            - name: BACKUP_STORAGE_PATH
              value: "/backup/storage"
            - name: VALIDATION_DATABASE
              value: "veridis_validation"

            envFrom:
            - secretRef:
                name: postgres-backup-secret
            - configMapRef:
                name: postgres-backup-config

            volumeMounts:
            - name: backup-storage
              mountPath: /backup/storage
              readOnly: true
            - name: validation-workspace
              mountPath: /validation
            - name: backup-scripts
              mountPath: /scripts
              readOnly: true

            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail

              source /scripts/backup-functions.sh
              source /scripts/validation-functions.sh

              echo "Starting comprehensive backup validation..."

              # Initialize validation environment
              initialize_validation_environment

              # Validate latest full backup
              validate_latest_full_backup

              # Validate incremental backup chain
              validate_incremental_backup_chain

              # Validate WAL archive integrity
              validate_wal_archive_integrity

              # Perform restoration test
              perform_restoration_test

              # Validate data integrity
              validate_restored_data_integrity

              # Generate validation report
              generate_validation_report

              # Send validation results
              send_validation_notification

              echo "Backup validation completed successfully"

            resources:
              requests:
                cpu: 1000m
                memory: 2Gi
              limits:
                cpu: 2000m
                memory: 4Gi

          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: postgres-backup-storage

          - name: validation-workspace
            emptyDir:
              sizeLimit: 10Gi

          - name: backup-scripts
            configMap:
              name: postgres-backup-scripts
              defaultMode: 0755

# ==============================================================================
# PostgreSQL Backup CronJobs Summary and Enterprise Backup Architecture
# ==============================================================================
#
# COMPREHENSIVE BACKUP STRATEGY:
# ==============================
#
# BACKUP ARCHITECTURE OVERVIEW:
# -----------------------------
# 1. Full Backup CronJob (postgres-full-backup):
#    - Weekly comprehensive database backup with parallel processing
#    - LZ4 compression with 70% average compression ratio
#    - AES-256 encryption with customer-managed keys
#    - Cross-region replication for disaster recovery
#    - 7-year retention with automated lifecycle management
#
# 2. Incremental Backup CronJob (postgres-incremental-backup):
#    - Daily incremental backup with change-based strategy
#    - WAL-based incremental processing for efficiency
#    - 30-day retention with backup chain management
#    - Point-in-time recovery capability
#    - Automated backup chain validation
#
# 3. WAL Archive Backup CronJob (postgres-wal-archive-backup):
#    - Hourly WAL segment archiving for continuous backup
#    - Transaction-level point-in-time recovery
#    - LZ4 compression for optimal performance
#    - 7-day retention with automated cleanup
#    - Continuous backup integrity monitoring
#
# 4. Backup Validation CronJob (postgres-backup-validation):
#    - Weekly comprehensive backup integrity verification
#    - Automated disaster recovery testing
#    - Restoration testing with data integrity validation
#    - Backup chain validation and reporting
#    - Compliance validation with audit reporting
#
# ENTERPRISE BACKUP FEATURES:
# ===========================
# Performance Optimization:
#   - Parallel backup processing with optimal resource utilization
#   - Intelligent compression with multiple algorithms (LZ4, gzip)
#   - Network-optimized transfer with bandwidth management
#   - Maintenance window scheduling for minimal impact
#   - Resource allocation with performance-cost balance
#
# Security and Encryption:
#   - AES-256 encryption with customer-managed keys
#   - Secure key management with HashiCorp Vault integration
#   - Encrypted transport with TLS 1.3
#   - Access control with RBAC and least privilege
#   - Comprehensive audit logging with immutable trails
#
# High Availability and Disaster Recovery:
#   - Cross-region replication for geographic redundancy
#   - Automated disaster recovery testing procedures
#   - Point-in-time recovery with transaction-level granularity
#   - Business continuity with RTO/RPO guarantees
#   - Backup validation with integrity verification
#
# Compliance and Governance:
#   - 7-year retention for regulatory compliance
#   - WORM compliance with immutable backup storage
#   - Comprehensive audit trails with blockchain anchoring
#   - Legal hold capability for litigation support
#   - Automated compliance reporting and validation
#
# OPERATIONAL EXCELLENCE:
# ======================
# Automation and Orchestration:
#   - Automated backup scheduling with dependency management
#   - Intelligent backup lifecycle with policy enforcement
#   - Backup chain management with validation
#   - Automated cleanup with retention policies
#   - Disaster recovery automation with testing
#
# Monitoring and Alerting:
#   - Comprehensive backup monitoring with performance metrics
#   - Real-time alerting with PagerDuty integration
#   - Backup SLA monitoring with compliance tracking
#   - Capacity forecasting with growth analysis
#   - Business impact analysis with cost optimization
#
# Cost Optimization:
#   - Intelligent storage tiering with lifecycle management
#   - Compression and deduplication for storage efficiency
#   - Reserved capacity for cost optimization
#   - Performance-cost balance with tiered strategies
#   - Automated cleanup with retention compliance
#
# ==============================================================================
